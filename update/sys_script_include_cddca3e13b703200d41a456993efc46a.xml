<?xml version="1.0" encoding="UTF-8"?>
<record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>sn_service_request.ServiceRequestManagement</api_name>
        <client_callable>false</client_callable>
        <description/>
        <name>ServiceRequestManagement</name>
        <script><![CDATA[var ServiceRequestManagement = Class.create();
ServiceRequestManagement.prototype = {
	initialize: function() {
	},

	assignAvailableWork: function(workerRequest) {
		checkWorkerRequest(workerRequest);
		gs.info("assignAvailableWork -- back from checkWorkerRequest");
		var workerGlideRecord = registerWorker(workerRequest);
		gs.info("assignAvailableWork -- back from registerWorker");
		var serviceRequestGlideRecord = matchAvailableServiceRequest(workerRequest.capabilities);
		gs.info("assignAvailableWork -- back from matchAvailableServiceRequest");
		return !gs.nil(serviceRequestGlideRecord) ? assignWork(serviceRequestGlideRecord, workerGlideRecord) : null;
	},

	scheduleService: function(serviceRequest) {
		checkServiceRequest(serviceRequest);

		var scheduledTime = deriveScheduledTime(serviceRequest);
		var priority = derivePriority(serviceRequest);

		var initialState = 'created';

		var serviceRequestGlideRecord = new GlideRecord("sn_service_request_service_request");
		serviceRequestGlideRecord.initialize();
		serviceRequestGlideRecord.token = serviceRequest.token;
		serviceRequestGlideRecord.state = initialState;
		serviceRequestGlideRecord.capability = loadCapability(serviceRequest.capability, true).getUniqueValue();
		serviceRequestGlideRecord.instance_name = serviceRequest.instance_name;
		serviceRequestGlideRecord.instance_id = serviceRequest.instance_id;
		serviceRequestGlideRecord.instance_url = serviceRequest.instance_url;
		serviceRequestGlideRecord.node_id = serviceRequest.node_id;
		serviceRequestGlideRecord.node_url = serviceRequest.node_url;
		serviceRequestGlideRecord.scheduled_time = scheduledTime;
		serviceRequestGlideRecord.priority = priority;
		serviceRequestGlideRecord.requested_by = gs.getUserName();
		var sys_id = serviceRequestGlideRecord.insert();

		trackServiceRequestState(sys_id, initialState);

		// Form a reply
		var schedule = {};
		schedule.token = serviceRequest.token;
		schedule.scheduledTime = scheduledTime.getDisplayValue();
		schedule.priority = priority;
		schedule.state = initialState;
		schedule.capability = serviceRequest.capability;
		return schedule;
	},

	cancel: function(serviceRequest) {
		// todo: implement
	},

	type: 'ServiceRequestManagement'
};

function deriveScheduledTime(serviceRequest) {
	// todo: in the future we may have more logic tied to this...
	return new GlideDateTime();
}

function derivePriority(serviceRequest) {
	// todo: in the future we may have more logic tied to this...
	return 100;
}

function loadCapability(capability, insertIfMissing) {
	var capabilityTableName = "sn_service_request_capability";

	var existingCapability = new GlideRecord(capabilityTableName);
	existingCapability.initialize();
	existingCapability.addQuery("type", capability.type);
	existingCapability.addQuery("name", capability.name);
	existingCapability.addQuery("version", capability.version);
	existingCapability.query();
	if (existingCapability.next()) {
		gs.info("leaving loadCapability with existing");
		return existingCapability;
	} else if (!gs.nil(insertIfMissing) && true == insertIfMissing) {
		var newCapability = new GlideRecord(capabilityTableName);
		newCapability.initialize();
		newCapability.type = capability.type;
		newCapability.name = capability.name;
		newCapability.version = capability.version;
		newCapability.insert();
		gs.info("leaving loadCapability with new");
		return newCapability;
	}
}

function assignWork(serviceRequestGlideRecord, workerGlideRecord) {
	// A given service request (token) can only be assigned once. No re-assignment.

	// Unfortunately, scoped apps don't have access to the GlideMutex library (sigh...).  Since we cannot lock
	// the service_request table we run the chance of an assignment race condition (e.g. two independent
	// worker id threads trying to assign themselves to the same service request). To mitigate
	// we try to detect if setting the "state" to "assigned" represents no change in lifecycle state (by looking at
	// the "sys_mod_count" before / after).  If the "sys_mod_count" didn't change then we've detected a race
	// condition, log it and leave.

	var assignedState = "assigned";

	var modCountBefore = serviceRequestGlideRecord.getValue("sys_mod_count");
	serviceRequestGlideRecord.setValue("state", assignedState);
	serviceRequestGlideRecord.update();
	var modCountAfter = serviceRequestGlideRecord.getValue("sys_mod_count");
	if (modCountAfter == modCountBefore) {
		gs.info("Service Request " + serviceRequestGlideRecord.getValue("token") + " has already been assigned. " +
			"Re-assignment is NOT permitted.");
		return;
	}

	// Not a re-assignment race condition :-) so complete the assignment.
	var assignmentGlideRecord = new GlideRecord("sn_service_request_assignment");
	assignmentGlideRecord.initialize();
	assignmentGlideRecord.service_request = serviceRequestGlideRecord.getUniqueValue();
	assignmentGlideRecord.worker = workerGlideRecord.getUniqueValue();
	assignmentGlideRecord.insert();

	trackServiceRequestState(serviceRequestGlideRecord.getUniqueValue(), assignedState);

	// Form a reply
	var assignment = {};
	assignment.coordinates = {};
	assignment.coordinates.token = serviceRequestGlideRecord.getValue("token");
	assignment.coordinates.instance_id = serviceRequestGlideRecord.getValue("instance_id");
	assignment.coordinates.instance_name = serviceRequestGlideRecord.getValue("instance_name");
	assignment.coordinates.instance_url = serviceRequestGlideRecord.getValue("instance_url");
	assignment.coordinates.node_id = serviceRequestGlideRecord.getValue("node_id");
	assignment.coordinates.node_url = serviceRequestGlideRecord.getValue("node_url");

	var workCapability = serviceRequestGlideRecord.capability.getRefRecord();
	assignment.capability = {};
	assignment.capability.type = workCapability.getValue("type");
	assignment.capability.name = workCapability.getValue("name");
	assignment.capability.version = workCapability.getValue("version");
	return assignment;
}

function matchAvailableServiceRequest(workerCapabilities) {
	var matchingCapabilityIds = [];
	for (i = 0; i < workerCapabilities.length; i++) {
		var capability = loadCapability(workerCapabilities[i], false);
		if (!gs.nil(capability)) {
			matchingCapabilityIds.push(capability.getUniqueValue());
		}
	}
	if (matchingCapabilityIds.length == 0) {
		return;
	}

	var serviceRequestGlideRecord = new GlideRecord("sn_service_request_service_request");
	serviceRequestGlideRecord.addQuery("state", "created");
	serviceRequestGlideRecord.addQuery("scheduled_time", "<=", new GlideDateTime());
	serviceRequestGlideRecord.addQuery("capability", "IN", matchingCapabilityIds.join());
	serviceRequestGlideRecord.orderBy("scheduled_time"); // todo: also by priority...
	serviceRequestGlideRecord.query();
	if (serviceRequestGlideRecord.next()) {
		return serviceRequestGlideRecord;
	}
}

function registerWorker(workerRequest) {
	var workerTableName = "sn_service_request_worker";
	var capabilitiesHash = stringToHashCode(stringifyCapablities(workerRequest.capabilities));
	var saveCapabilities = false;
	var worker;

	var existingWorker = new GlideRecord(workerTableName);
	existingWorker.initialize();
	existingWorker.addQuery("name", workerRequest.name);
	existingWorker.query();
	if (existingWorker.next()) {
		worker = existingWorker;
		if (existingWorker.getValue("capabilities_hash") != capabilitiesHash) {
			existingWorker.capabilities_hash = capabilitiesHash;
			existingWorker.update();
			saveCapabilities = true;
		}
	} else {
		var newWorker = new GlideRecord(workerTableName);
		newWorker.initialize();
		newWorker.name = workerRequest.name;
		newWorker.capabilities_hash = capabilitiesHash;
		newWorker.insert();
		worker = newWorker;
		saveCapabilities = true;
	}

	if (saveCapabilities) {
		for (i = 0; i < workerRequest.capabilities.length; i++) {
			loadCapability(workerRequest.capabilities[i], true);
		}
	}

	return worker;
}

function trackServiceRequestState(serviceRequestSysId, state) {
	var gr = new GlideRecord('sn_service_request_service_request_status');
	gr.initialize();
	gr.service_request = serviceRequestSysId;
	gr.state = state;
	gr.insert();

	// todo: need to figure out a cascade-delete strategy
}

function checkServiceRequest(serviceRequest) {
	// Parameter validation
	if (gs.nil(serviceRequest) || gs.nil(serviceRequest.token) ||
		gs.nil(serviceRequest.instance_name) || gs.nil(serviceRequest.instance_url) ||
		gs.nil(serviceRequest.instance_id) || gs.nil(serviceRequest.node_id) ||
		gs.nil(serviceRequest.node_url)
	) {
		throw "serviceRequest parameter is malformed. It requires the following fields: token, instance_name, " +
		"instance_url, instance_id, node_id, node_url, capability";
	}

	var error = checkCapability(serviceRequest.capability);
	if (!gs.nil(error)) {
		throw error;
	}

	// Make sure the token does not already exist.
	var count = new GlideAggregate("sn_service_request_service_request");
	count.addQuery("token", serviceRequest.token);
	count.addAggregate("COUNT");
	count.query();
	if (count.next()) {
		if (count.getAggregate("COUNT") > 0) {
			throw "Duplicate service request token " + serviceRequest.token + ".";
		}
	}
}

function checkWorkerRequest(workerRequest) {
	if (gs.nil(workerRequest) || gs.nil(workerRequest.name) || gs.nil(workerRequest.capabilities) ||
		gs.nil(workerRequest.capabilities.length) || 0 == workerRequest.capabilities.length
	) {
		throw "workerRequest is malformed. It requires the following fields: name, capabilities";
	}

	for (i = 0; i < workerRequest.capabilities.length; i++) {
		var error = checkCapability(workerRequest.capabilities[i]);
		if (!gs.nil(error)) {
			throw error;
		}
	}
}

function checkCapability(capability) {
	if (gs.nil(capability) || gs.nil(capability.type) || gs.nil(capability.name) || gs.nil(capability.version)) {
		throw "capability is incomplete. It requires the following fields: type, name, version";
	}
}

function stringifyCapablities(capabablities) {
	if (gs.nil(capabablities) || gs.nil(capabablities.length) == null || capabablities.length == 0) {
		return;
	}

	var i, k;
	var keys = [];
	var capabilitiesMap = [capabablities.length];

	for (i = 0; i < capabablities.length; i++) {
		var capabablity = capabablities[i];
		keys.push(capabablity.name);
		capabilitiesMap[capabablity.name] = capabablity;
	}

	keys.sort();
	var len = keys.length;
	var str = "";

	for (i = 0; i < len; i++) {
		if (i > 0) {
			str += "; ";
		}
		k = keys[i];
		var capability = capabilitiesMap[k];
		str += "[" + i + "] = type:" + capability.type + ", name:" + capability.name + ", version:" + capability.version;
	}

	return str;
}

function stringToHashCode(str){
	var hash = 0;
	if (str.length == 0) return hash;
	for (i = 0; i < str.length; i++) {
		var ch = str.charCodeAt(i);
		hash = ((hash<<5)-hash)+ch;
		hash = hash & hash;
	}
	return hash;
}
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2017-02-07 21:59:03</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>cddca3e13b703200d41a456993efc46a</sys_id>
        <sys_mod_count>87</sys_mod_count>
        <sys_name>ServiceRequestManagement</sys_name>
        <sys_package display_value="Service Request Management" source="sn_service_request">c8a02be10b303200d109061437673a7b</sys_package>
        <sys_policy>read</sys_policy>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Service Request Management">c8a02be10b303200d109061437673a7b</sys_scope>
        <sys_update_name>sys_script_include_cddca3e13b703200d41a456993efc46a</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2017-02-09 23:18:44</sys_updated_on>
    </sys_script_include>
</record_update>
